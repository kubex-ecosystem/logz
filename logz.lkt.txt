/// core/entry.go ///
package logz

import (
	"errors"
	"fmt"
	"runtime"
	"time"
)

// Entry é o núcleo de dado do logz.
// Simples, estruturado, chainable.
type Entry struct {
	Timestamp time.Time         `json:"ts"`
	Level     Level             `json:"level"`
	Message   string            `json:"msg"`
	Source    string            `json:"source,omitempty"`
	Context   string            `json:"ctx,omitempty"`
	Tags      map[string]string `json:"tags,omitempty"`
	Fields    map[string]any    `json:"fields,omitempty"`
	TraceID   string            `json:"trace_id,omitempty"`
	Caller    string            `json:"caller,omitempty"`
	Severity  int               `json:"severity"`
}

// NewEntry cria uma entry básica, preenchendo timestamp e caller.
func NewEntry() *Entry {
	return &Entry{
		Timestamp: time.Now().UTC(),
		Tags:      make(map[string]string),
		Fields:    make(map[string]any),
		Caller:    caller(3),
	}
}

// --- Chainable ---

func (e *Entry) WithLevel(l Level) *Entry {
	e.Level = l
	e.Severity = l.Severity()
	return e
}

func (e *Entry) WithMessage(msg string) *Entry {
	e.Message = msg
	return e
}

func (e *Entry) WithSource(src string) *Entry {
	e.Source = src
	return e
}

func (e *Entry) WithContext(ctx string) *Entry {
	e.Context = ctx
	return e
}

func (e *Entry) WithTraceID(id string) *Entry {
	e.TraceID = id
	return e
}

func (e *Entry) Tag(key, value string) *Entry {
	if e.Tags == nil {
		e.Tags = make(map[string]string)
	}
	e.Tags[key] = value
	return e
}

func (e *Entry) Field(key string, value any) *Entry {
	if e.Fields == nil {
		e.Fields = make(map[string]any)
	}
	e.Fields[key] = value
	return e
}

// Validate garante que a entry não é um lixo incompleto.
func (e *Entry) Validate() error {
	if e == nil {
		return errors.New("entry is nil")
	}
	if e.Timestamp.IsZero() {
		return errors.New("timestamp is required")
	}
	if e.Level == "" {
		return errors.New("level is required")
	}
	if e.Message == "" {
		return errors.New("message is required")
	}
	if e.Severity <= 0 {
		return errors.New("severity must be greater than zero")
	}
	return nil
}

func (e *Entry) String() string {
	if e == nil {
		return "<nil entry>"
	}
	return fmt.Sprintf("%s [%s] %s", e.Timestamp.Format(time.RFC3339), e.Level, e.Message)
}

func caller(skip int) string {
	pc, file, line, ok := runtime.Caller(skip)
	if !ok {
		return "unknown"
	}
	fn := runtime.FuncForPC(pc)
	if fn == nil {
		return fmt.Sprintf("%s:%d", file, line)
	}
	return fmt.Sprintf("%s:%d %s", file, line, fn.Name())
}
/// core/fields.go ///
package logz

// Field é uma função que muta a Entry, usada na API funcional.
type Field func(*Entry)

func FTag(key, value string) Field {
	return func(e *Entry) {
		if e.Tags == nil {
			e.Tags = make(map[string]string)
		}
		e.Tags[key] = value
	}
}

func FField(key string, value any) Field {
	return func(e *Entry) {
		if e.Fields == nil {
			e.Fields = make(map[string]any)
		}
		e.Fields[key] = value
	}
}

func FContext(ctx string) Field {
	return func(e *Entry) {
		e.Context = ctx
	}
}

func FSource(src string) Field {
	return func(e *Entry) {
		e.Source = src
	}
}

func FTrace(id string) Field {
	return func(e *Entry) {
		e.TraceID = id
	}
}
/// core/levels.go ///
package logz

import "strings"

// Level representa o nível semântico do log.
type Level string

const (
	LevelDebug  Level = "debug"
	LevelInfo   Level = "info"
	LevelWarn   Level = "warn"
	LevelError  Level = "error"
	LevelFatal  Level = "fatal"
	LevelSilent Level = "silent"
)

func (l Level) String() string { return string(l) }

func ParseLevel(s string) Level {
	switch strings.ToLower(s) {
	case "debug":
		return LevelDebug
	case "info":
		return LevelInfo
	case "warn", "warning":
		return LevelWarn
	case "error", "err":
		return LevelError
	case "fatal":
		return LevelFatal
	case "silent", "":
		return LevelSilent
	default:
		return LevelInfo
	}
}

func (l Level) Severity() int {
	switch l {
	case LevelDebug:
		return 10
	case LevelInfo:
		return 20
	case LevelWarn:
		return 30
	case LevelError:
		return 40
	case LevelFatal:
		return 50
	default:
		return 0
	}
}
/// core/logger.go ///
package logz

import (
	"os"
	"sync"

	// formatter "github.com/kubex-ecosystem/logz/internal/formatter"
	"github.com/kubex-ecosystem/logz/interfaces"
	writer "github.com/kubex-ecosystem/logz/internal/writer"
)

// Logger é a entidade que junta Entry + Formatter + Writer.
type Logger struct {
	mu        sync.RWMutex
	formatter interfaces.Formatter
	writer    writer.Writer
	minLevel  Level
}

type LoggerOption func(*Logger)

func WithFormatter(f interfaces.Formatter) LoggerOption {
	return func(l *Logger) { l.formatter = f }
}

func WithWriter(w interfaces.Writer) LoggerOption {
	return func(l *Logger) { l.writer = nil }
}

func WithMinLevel(lv Level) LoggerOption {
	return func(l *Logger) { l.minLevel = lv }
}

func NewLogger(opts ...LoggerOption) *Logger {
	l := &Logger{
		// formatter: formatter.NewPrettyFormatter(),
		writer:   writer.NewIOWriter(os.Stdout),
		minLevel: LevelDebug,
	}
	for _, opt := range opts {
		opt(l)
	}
	return l
}

func (l *Logger) shouldLog(lv Level) bool {
	return lv.Severity() >= l.minLevel.Severity()
}

func (l *Logger) log(e *Entry) error {
	if !l.shouldLog(e.Level) {
		return nil
	}
	l.mu.RLock()
	f := l.formatter
	w := l.writer
	l.mu.RUnlock()

	if f == nil || w == nil {
		return nil
	}

	// b, err := f.Format(e)
	b, err := f.Format(nil)
	if err != nil {
		return err
	}
	// garantir newline se o formatter não colocou
	if len(b) == 0 || b[len(b)-1] != '\n' {
		b = append(b, '\n')
	}
	return w.Write(b)
}

// EntryBuilder: API chainable orientada a Entry + Logger.

type EntryBuilder struct {
	logger *Logger
	entry  *Entry
}

func (l *Logger) Entry() *EntryBuilder {
	return &EntryBuilder{
		logger: l,
		entry:  NewEntry(),
	}
}

func (b *EntryBuilder) Level(lv Level) *EntryBuilder {
	b.entry.WithLevel(lv)
	return b
}

func (b *EntryBuilder) Msg(msg string) error {
	b.entry.WithMessage(msg)
	return b.logger.log(b.entry)
}

func (b *EntryBuilder) Context(ctx string) *EntryBuilder {
	b.entry.WithContext(ctx)
	return b
}

func (b *EntryBuilder) Source(src string) *EntryBuilder {
	b.entry.WithSource(src)
	return b
}

func (b *EntryBuilder) Trace(id string) *EntryBuilder {
	b.entry.WithTraceID(id)
	return b
}

func (b *EntryBuilder) Tag(k, v string) *EntryBuilder {
	b.entry.Tag(k, v)
	return b
}

func (b *EntryBuilder) Field(k string, v any) *EntryBuilder {
	b.entry.Field(k, v)
	return b
}

// Conveniências por nível

func (l *Logger) Debug(msg string, fields ...Field) error {
	return l.logFrom(LevelDebug, msg, fields...)
}

func (l *Logger) Info(msg string, fields ...Field) error {
	return l.logFrom(LevelInfo, msg, fields...)
}

func (l *Logger) Warn(msg string, fields ...Field) error {
	return l.logFrom(LevelWarn, msg, fields...)
}

func (l *Logger) Error(msg string, fields ...Field) error {
	return l.logFrom(LevelError, msg, fields...)
}

func (l *Logger) Fatal(msg string, fields ...Field) error {
	err := l.logFrom(LevelFatal, msg, fields...)
	_ = l.writer.Close()
	os.Exit(1)
	return err
}

func (l *Logger) logFrom(lv Level, msg string, fields ...Field) error {
	e := NewEntry().WithLevel(lv).WithMessage(msg)
	for _, f := range fields {
		f(e)
	}
	return l.log(e)
}
/// formatter/formatter.go ///
package formatter

import (
	core "github.com/kubex-ecosystem/logz/internal/core"
)

// Formatter transforma uma Entry em bytes prontos pra IO.
// NÃO escreve em lugar nenhum. Só formata.
type Formatter interface {
	Format(*core.Entry) ([]byte, error)
}
/// formatter/json_formatter.go ///
// Package formatter provides a JSON formatter for log entries.
package formatter

import (
	"encoding/json"

	"github.com/kubex-ecosystem/logz/interfaces"
)

type JSONFormatter struct {
	Pretty bool
}

func NewJSONFormatter(pretty bool) *JSONFormatter {
	return &JSONFormatter{Pretty: pretty}
}

func (f *JSONFormatter) Format(e interfaces.Entry) ([]byte, error) {
	if err := e.Validate(); err != nil {
		return nil, err
	}
	if f.Pretty {
		return json.MarshalIndent(e, "", "  ")
	}
	return json.Marshal(e)
}
/// formatter/minimal_formatter.go ///
package formatter

import (
	"github.com/kubex-ecosystem/logz/interfaces"
)

// MinimalFormatter: LEVEL message\n
type MinimalFormatter struct{}

func NewMinimalFormatter() *MinimalFormatter { return &MinimalFormatter{} }

func (f *MinimalFormatter) Format(e interfaces.Entry) ([]byte, error) {
	if err := e.Validate(); err != nil {
		return nil, err
	}
	// line := fmt.Sprintf("%s %s\n", e.Level, e.Message)
	// return []byte(line), nil
	return nil, nil
}
/// formatter/pretty_formatter.go ///
package formatter

import (
	"bytes"

	"github.com/kubex-ecosystem/logz/interfaces"
)

type PrettyFormatter struct {
	TimeLayout string
	WithColors bool
}

func NewPrettyFormatter() *PrettyFormatter {
	return &PrettyFormatter{
		TimeLayout: "15:04:05.000",
		WithColors: true,
	}
}

func (f *PrettyFormatter) Format(e interfaces.Entry) ([]byte, error) {
	if err := e.Validate(); err != nil {
		return nil, err
	}

	var buf bytes.Buffer

	// ts := e.Timestamp.In(time.Local).Format(f.TimeLayout)
	// level := string(e.Level)

	// levelStr := level
	// if f.WithColors {
	// 	levelStr = colorForLevel(e.Level, level)
	// }

	// fmt.Fprintf(&buf, "%s  %s  %s", ts, levelStr, e.Message)
	// if e.Context != "" {
	// 	fmt.Fprintf(&buf, "  (%s)", e.Context)
	// }
	// buf.WriteByte('\n')

	// // tags e fields em linhas subsequentes
	// if len(e.Tags) > 0 || len(e.Fields) > 0 || e.Caller != "" {
	// 	keys := make([]string, 0, len(e.Tags))
	// 	for k := range e.Tags {
	// 		keys = append(keys, k)
	// 	}
	// 	sort.Strings(keys)

	// 	if len(keys) > 0 {
	// 		buf.WriteString("  tags: ")
	// 		for i, k := range keys {
	// 			if i > 0 {
	// 				buf.WriteString(" ")
	// 			}
	// 			fmt.Fprintf(&buf, "%s=%s", k, e.Tags[k])
	// 		}
	// 		buf.WriteByte('\n')
	// 	}

	// 	fkeys := make([]string, 0, len(e.Fields))
	// 	for k := range e.Fields {
	// 		fkeys = append(fkeys, k)
	// 	}
	// 	sort.Strings(fkeys)

	// 	if len(fkeys) > 0 {
	// 		buf.WriteString("  fields: ")
	// 		for i, k := range fkeys {
	// 			if i > 0 {
	// 				buf.WriteString(" ")
	// 			}
	// 			fmt.Fprintf(&buf, "%s=%v", k, e.Fields[k])
	// 		}
	// 		buf.WriteByte('\n')
	// 	}

	// 	if e.Caller != "" {
	// 		fmt.Fprintf(&buf, "  caller: %s\n", e.Caller)
	// 	}
	// }

	return buf.Bytes(), nil
}

func colorForLevel(l string, s string) string {
	const (
		reset   = "\x1b[0m"
		gray    = "\x1b[90m"
		green   = "\x1b[32m"
		yellow  = "\x1b[33m"
		red     = "\x1b[31m"
		magenta = "\x1b[35m"
	)
	switch l {
	case "debug":
		return gray + s + reset
	case "info":
		return green + s + reset
	case "warn":
		return yellow + s + reset
	case "error":
		return red + s + reset
	case "fatal":
		return magenta + s + reset
	default:
		return s
	}
}
/// module/control/secflags.go ///
package control

import (
	"fmt"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
)

/* ========= FLAGS ========= */

type SecFlag uint32

const (
	SecNone         SecFlag = 0
	SecAuth         SecFlag = 1 << iota // autenticação/autorização
	SecSanitize                         // sanitize em params/headers
	SecSanitizeBody                     // sanitize no body
)

func (f SecFlag) Has(mask SecFlag) bool { return f&mask == mask }
func (f SecFlag) Any(mask SecFlag) bool { return f&mask != 0 }
func (f SecFlag) With(mask SecFlag) SecFlag {
	return f | mask
}
func (f SecFlag) Without(mask SecFlag) SecFlag {
	return f &^ mask
}

// ordem determinística para log/telemetria
var secOrder = []struct {
	name string
	flag SecFlag
}{
	{"auth", SecAuth},
	{"sanitize", SecSanitize},
	{"sanitize_body", SecSanitizeBody},
}

func (f SecFlag) String() string {
	if f == SecNone {
		return "none"
	}
	var parts []string
	for _, it := range secOrder {
		if f.Has(it.flag) {
			parts = append(parts, it.name)
		}
	}
	if len(parts) == 0 {
		return fmt.Sprintf("unknown(0x%X)", uint32(f))
	}
	return strings.Join(parts, "|")
}

/* ======== REGISTRADOR ATÔMICO ======== */

type FlagReg32A[T ~uint32] struct{ v atomic.Uint32 }

// Set  CAS OR (não usa Add; evita somas indevidas quando máscara tem múltiplos bits)
func (r *FlagReg32A[T]) Set(mask T) {
	for {
		old := r.v.Load()
		newV := old | uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return
		}
	}
}

// Clear CAS AND NOT
func (r *FlagReg32A[T]) Clear(mask T) {
	for {
		old := r.v.Load()
		newV := old &^ uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return
		}
	}
}

// Load current value
func (r *FlagReg32A[T]) Load() T { return T(r.v.Load()) }

// SetIf CAS OR se todos os bits de mustHave estiverem setados
func (r *FlagReg32A[T]) SetIf(mask, mustHave T) bool {
	for {
		old := r.v.Load()
		if (old & uint32(mustHave)) != uint32(mustHave) {
			return false
		}
		newV := old | uint32(mask)
		if r.v.CompareAndSwap(old, newV) {
			return true
		}
	}
}

// ======== MAP LEGADO -> FLAGS ========

// FromLegacyMap converte mapa legado (ex: de config JSON) para flags
func FromLegacyMap(m map[string]bool) SecFlag {
	if m == nil {
		return SecNone
	}
	var f SecFlag
	if m["auth"] {
		f |= SecAuth
	}
	if m["sanitize"] {
		f |= SecSanitize
	}
	if m["sanitize_body"] || m["validateAndSanitizeBody"] {
		f |= SecSanitizeBody
	}
	// compat antiga
	if m["validateAndSanitize"] {
		f |= SecSanitize
	}
	return f
}

/* ======== JOB STATES (bitmask) ======== */

type JobFlagC uint32

const (
	JobNone     JobFlagC = 0
	JobRunningC JobFlagC = 1 << iota
	JobRetryingC
	JobCompletedC
	JobFailedC
	JobTimedOutC
)

func (f JobFlagC) Has(mask JobFlagC) bool { return f&mask == mask }

type JobStateS struct{ reg FlagReg32[uint32] }

func (s *JobStateS) Load() JobFlagC { return JobFlagC(s.reg.Load()) }

func (s *JobStateS) Start() {
	s.reg.Clear(uint32(JobCompletedC | JobFailedC | JobTimedOutC))
	s.reg.Set(uint32(JobRunningC))
}

func (s *JobStateS) Retry() {
	// só marca retry se estava running
	_ = s.reg.SetIf(uint32(JobRetryingC), uint32(JobRunningC))
}

func (s *JobStateS) Complete() {
	// terminal limpa outros
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobFailedC | JobTimedOutC))
	s.reg.Set(uint32(JobCompletedC))
}

func (s *JobStateS) Fail() {
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobCompletedC | JobTimedOutC))
	s.reg.Set(uint32(JobFailedC))
}

func (s *JobStateS) Timeout() {
	s.reg.Clear(uint32(JobRunningC | JobRetryingC | JobCompletedC | JobFailedC))
	s.reg.Set(uint32(JobTimedOutC))
}

// String returns a string representation of the JobFlagC flags that are set.
// The output is a sorted, pipe-separated list of flag names (e.g., "completed|running").
// If no flags are set, it returns "none".
func (f JobFlagC) String() string {
	order := []struct {
		n string
		b JobFlagC
	}{
		{"running", JobRunningC},
		{"retrying", JobRetryingC},
		{"completed", JobCompletedC},
		{"failed", JobFailedC},
		{"timeout", JobTimedOutC},
	}
	var on []string
	for _, it := range order {
		if f.Has(it.b) {
			on = append(on, it.n)
		}
	}
	if len(on) == 0 {
		return "none"
	}
	sort.Strings(on)
	return strings.Join(on, "|")
}

func TestFlagReg32SetAndClear(t *testing.T) {
	var r FlagReg32[uint32]
	r.Set(uint32(SecAuth | SecSanitize))
	if got := SecFlag(r.Load()); !got.Has(SecAuth | SecSanitize) {
		t.Fatalf("expected flags set, got %v", got)
	}
	r.Clear(uint32(SecSanitize))
	if got := SecFlag(r.Load()); got.Has(SecSanitize) {
		t.Fatalf("sanitize should be cleared, got %v", got)
	}
}

func TestFlagReg32Concurrent(t *testing.T) {
	var r FlagReg32[uint32]
	wg := sync.WaitGroup{}
	N := 1000
	wg.Add(N)
	for i := 0; i < N; i++ {
		go func(i int) {
			defer wg.Done()
			if i%2 == 0 {
				r.Set(uint32(SecAuth))
			} else {
				r.Set(uint32(SecSanitize))
			}
		}(i)
	}
	wg.Wait()
	got := SecFlag(r.Load())
	if !got.Has(SecAuth) || !got.Has(SecSanitize) {
		t.Fatalf("expected both bits set, got %v", got)
	}
}

func TestJobStateTransitions(t *testing.T) {
	var s JobState
	s.Start()

	JobRunning := JobFlag(1 << 0)
	JobRetrying := JobFlag(1 << 1)
	JobCompleted := JobFlag(1 << 2)
	JobFailed := JobFlag(1 << 3)
	JobTimedOut := JobFlag(1 << 4)

	if st := s.Load(); !st.Has(JobRunning) {
		t.Fatalf("start → running, got %v", st)
	}
	s.Retry()
	if st := s.Load(); !st.Has(JobRetrying) {
		t.Fatalf("retry flag missing, got %v", st)
	}
	s.Complete()
	if st := s.Load(); !st.Has(JobCompleted) || st.Has(JobRunning|JobRetrying) {
		t.Fatalf("complete should be terminal only, got %v", st)
	}
	s.Start()
	s.Fail()
	if st := s.Load(); !st.Has(JobFailed) || st.Has(JobRunning) {
		t.Fatalf("failed should be terminal only, got %v", st)
	}
	s.Timeout()
	if st := s.Load(); !st.Has(JobTimedOut) || st.Has(JobRunning) {
		t.Fatalf("timeout should be terminal only, got %v", st)
	}
}
/// module/control/state.go ///
// Package control provides abstractions for managing job states and security flags.
package control

import (
	"errors"
	"sync/atomic"
)

// Example: Job state flags (combináveis) -------------------------------------

type JobFlag uint32

const (
	JobPendingA JobFlag = 1 << iota
	JobRunningA
	JobCancelRequestedA
	JobRetryingA
	JobCompletedA
	JobFailedA
	JobTimedOutA
)

const (
	terminalMask JobFlag = JobCompletedA | JobFailedA | JobTimedOutA
)

var (
	ErrTerminal = errors.New("job is in a terminal state")
)

func (j JobFlag) Has(flag JobFlag) bool {
	return j&flag != 0
}

type FlagReg32[T ~uint32] struct{ v atomic.Uint32 }

func (r *FlagReg32[T]) Load() T { return T(r.v.Load()) }
func (r *FlagReg32[T]) Store(val T) {
	r.v.Store(uint32(val))
}
func (r *FlagReg32[T]) Set(mask T) { r.v.Add(uint32(mask)) }
func (r *FlagReg32[T]) Clear(mask T) {
	for {
		old := r.v.Load()
		if r.v.CompareAndSwap(old, old&^uint32(mask)) {
			return
		}
	}
}
func (r *FlagReg32[T]) SetIf(clearMask, setMask T) bool {
	for {
		old := r.v.Load()
		if old&uint32(clearMask) != 0 {
			return false
		}
		newV := (old &^ uint32(clearMask)) | uint32(setMask)
		if r.v.CompareAndSwap(old, newV) {
			return true
		}
	}
}
func (r *FlagReg32[T]) Any(mask T) bool { return r.v.Load()&uint32(mask) != 0 }
func (r *FlagReg32[T]) All(mask T) bool { return r.v.Load()&uint32(mask) == uint32(mask) }

type JobState struct{ r FlagReg32[JobFlag] }

func (s *JobState) Load() JobFlag { return s.r.Load() }

// Start only from Pending; sets Running.
func (s *JobState) Start() error {
	ok := s.r.SetIf(terminalMask|JobRunningA|JobCompletedA|JobFailedA|JobTimedOutA, JobRunningA)
	if !ok {
		return ErrTerminal
	}
	return nil
}

// RequestCancel sets the CancelRequested flag.
func (s *JobState) RequestCancel() { s.r.Set(JobCancelRequestedA) }

// Retry sets the job state to Retrying if not in a terminal state.
func (s *JobState) Retry() error {
	// can retry if not terminal; set Retrying and clear Running
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobRetryingA) &^ JobRunningA
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Complete sets the job state to Completed.
func (s *JobState) Complete() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobCompletedA) &^ (JobRunningA | JobRetryingA | JobCancelRequestedA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Fail sets the job state to Failed.
func (s *JobState) Fail() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobFailedA) &^ (JobRunningA | JobRetryingA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// Timeout sets the job state to TimedOut.
func (s *JobState) Timeout() error {
	for {
		old := s.r.Load()
		if old&terminalMask != 0 {
			return ErrTerminal
		}
		newV := (old | JobTimedOutA) &^ (JobRunningA | JobRetryingA)
		if s.r.SetIf(old, newV) {
			return nil
		}
	}
}

// IsTerminal returns true if the job is in a terminal state.
func (s *JobState) IsTerminal() bool { return s.r.Any(terminalMask) }
/// module/info/application.go ///
// Package info provides functionality to read and parse the application manifest.
package info

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"strings"
)

var banners = []string{
	`
 __
|  \
| ▓▓       ______   ______  ________
| ▓▓      /      \ /      \|        \
| ▓▓     |  ▓▓▓▓▓▓\  ▓▓▓▓▓▓\\▓▓▓▓▓▓▓▓
| ▓▓     | ▓▓  | ▓▓ ▓▓  | ▓▓ /    ▓▓
| ▓▓_____| ▓▓__/ ▓▓ ▓▓__| ▓▓/  ▓▓▓▓_
| ▓▓     \\▓▓    ▓▓\▓▓    ▓▓  ▓▓    \
 \▓▓▓▓▓▓▓▓ \▓▓▓▓▓▓ _\▓▓▓▓▓▓▓\▓▓▓▓▓▓▓▓
                  |  \__| ▓▓
                   \▓▓    ▓▓
                    \▓▓▓▓▓▓
`,
}

func GetDescriptions(descriptionArg []string, hideBanner bool) map[string]string {
	var description, banner string

	if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
		description = descriptionArg[0]
	} else {
		if len(descriptionArg) > 1 {
			description = descriptionArg[1]
		} else {
			description = descriptionArg[0]
		}
	}

	if !hideBanner {
		banner = banners[rand.Intn(len(banners))]
	} else {
		banner = ""
	}
	return map[string]string{"banner": banner, "description": description}
}

//go:embed manifest.json
var manifestJSONData []byte

// var application Manifest

type Reference struct {
	Name            string `json:"name"`
	ApplicationName string `json:"application"`
	Bin             string `json:"bin"`
	Version         string `json:"version"`
}

type mmanifest struct {
	Manifest
	Name            string   `json:"name"`
	ApplicationName string   `json:"application"`
	Bin             string   `json:"bin"`
	Version         string   `json:"version"`
	Repository      string   `json:"repository"`
	Aliases         []string `json:"aliases,omitempty"`
	Homepage        string   `json:"homepage,omitempty"`
	Description     string   `json:"description,omitempty"`
	Main            string   `json:"main,omitempty"`
	Author          string   `json:"author,omitempty"`
	License         string   `json:"license,omitempty"`
	Keywords        []string `json:"keywords,omitempty"`
	Platforms       []string `json:"platforms,omitempty"`
	LogLevel        string   `json:"log_level,omitempty"`
	Debug           bool     `json:"debug,omitempty"`
	ShowTrace       bool     `json:"show_trace,omitempty"`
	Private         bool     `json:"private,omitempty"`
}
type Manifest interface {
	GetName() string
	GetVersion() string
	GetAliases() []string
	GetRepository() string
	GetHomepage() string
	GetDescription() string
	GetMain() string
	GetBin() string
	GetAuthor() string
	GetLicense() string
	GetKeywords() []string
	GetPlatforms() []string
	IsPrivate() bool
}

func (m *mmanifest) GetName() string        { return m.Name }
func (m *mmanifest) GetVersion() string     { return m.Version }
func (m *mmanifest) GetAliases() []string   { return m.Aliases }
func (m *mmanifest) GetRepository() string  { return m.Repository }
func (m *mmanifest) GetHomepage() string    { return m.Homepage }
func (m *mmanifest) GetDescription() string { return m.Description }
func (m *mmanifest) GetMain() string        { return m.Main }
func (m *mmanifest) GetBin() string         { return m.Bin }
func (m *mmanifest) GetAuthor() string      { return m.Author }
func (m *mmanifest) GetLicense() string     { return m.License }
func (m *mmanifest) GetKeywords() []string  { return m.Keywords }
func (m *mmanifest) GetPlatforms() []string { return m.Platforms }
func (m *mmanifest) IsPrivate() bool        { return m.Private }

// lazy cache
var (
	cachedManifest Manifest
	cachedControl  *Control
)

// GetManifest lazy, sem init() com side-effects
func GetManifest() (Manifest, error) {
	if cachedManifest != nil {
		return cachedManifest, nil
	}

	if len(manifestJSONData) == 0 {
		return nil, fmt.Errorf("manifest.json: embed is empty")
	}

	var m mmanifest
	if err := json.Unmarshal(manifestJSONData, &m); err != nil {
		return nil, fmt.Errorf("manifest.json: %w", err)
	}
	cachedManifest = &m
	return &m, nil
}

// FS secOrder quiser permitir override por FS externo:
type FS interface {
	ReadFile(name string) ([]byte, error)
}

func LoadFromFS(fs FS) (Manifest, Control, error) {
	var m Manifest
	var c Control
	if b, err := fs.ReadFile("manifest.json"); err == nil {
		if err := json.Unmarshal(b, &m); err != nil {
			return nil, Control{}, fmt.Errorf("manifest.json: %w", err)
		}
	} else {
		return nil, Control{}, fmt.Errorf("manifest.json: %w", err)
	}
	if b, err := fs.ReadFile("control.json"); err == nil {
		if err := json.Unmarshal(b, &c); err != nil {
			return nil, Control{}, fmt.Errorf("control.json: %w", err)
		}
	} else {
		return nil, Control{}, fmt.Errorf("control.json: %w", err)
	}
	return m, c, nil
}

// func GetControl() (*Control, error) {
// 	if cachedControl != nil {
// 		return cachedControl, nil
// 	}
// 	var c Control
// 	if len(controlJSONData) == 0 {
// 		return nil, fmt.Errorf("control.json: embed is empty")
// 	}
// 	if err := json.Unmarshal(controlJSONData, &c); err != nil {
// 		return nil, fmt.Errorf("control.json: %w", err)
// 	}
// 	cachedControl = &c
// 	return &c, nil
// }
/// module/info/control.go ///
// Package info gerencia controle e configuração modular, com suporte a arquivos separados por módulo.
package info

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// Control representa a configuração de controle de um módulo.
type Control struct {
	Reference     Reference `json:"-"` // Usado internamente para nome do arquivo, nunca exportado
	SchemaVersion int       `json:"schema_version"`
	IPC           IPC       `json:"ipc"`
	Bitreg        Bitreg    `json:"bitreg"`
	KV            KV        `json:"kv"`
	Seq           int       `json:"seq"`
	EpochNS       int64     `json:"epoch_ns"`
}

func (c *Control) GetName() string    { return c.Reference.Name }
func (c *Control) GetVersion() string { return c.Reference.Version }

// LoadControlByModule carrega o controle de um arquivo específico do módulo.
func LoadControlByModule(dir string, moduleName string) (*Control, error) {
	file := filepath.Join(dir, fmt.Sprintf("control_%s.json", moduleName))
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("erro ao abrir %s: %w", file, err)
	}
	defer f.Close()
	var c Control
	dec := json.NewDecoder(f)
	if err := dec.Decode(&c); err != nil {
		return nil, fmt.Errorf("erro ao decodificar %s: %w", file, err)
	}
	c.Reference = Reference{Name: moduleName}
	return &c, nil
}

// SaveControl salva o controle do módulo em arquivo separado.
func (c *Control) SaveControl(dir string) error {
	if c.Reference.Name == "" {
		return fmt.Errorf("Reference.Name não pode ser vazio para salvar o controle")
	}
	file := filepath.Join(dir, fmt.Sprintf("control_%s.json", c.Reference.Name))
	f, err := os.Create(file)
	if err != nil {
		return fmt.Errorf("erro ao criar %s: %w", file, err)
	}
	defer f.Close()
	enc := json.NewEncoder(f)
	enc.SetIndent("", "  ")
	// Reference não é exportado
	return enc.Encode(c)
}
/// module/info/control.json ///
{
  "control": {
    "schema_version": 1,
    "module": {
      "name": "Kubex - Grompt",
      "application": "grompt",
      "module_id": "0x7a12c3f1"
    },
    "ipc": {
      "type": "unix",
      "socket": "/run/kbx/grompt.sock",
      "mode": "0600"
    },
    "bitreg": {
      "brf_path": "/var/run/kbx/registry.brf",
      "ns_bits": 1024,
      "policy": "shared",
      "cap_mask": "0x0000000000000000",
      "state_hex": "0x000000000000000b"
    },
    "kv": {
      "declare_hashes": [
        {
          "key_hash": "0x8f12ab34"
        },
        {
          "key_hash": "0x91cc77fe"
        }
      ],
      "values": [
        {
          "key_hash": "0x8f12ab34",
          "u64_hex": "0x0abc00001f90"
        },
        {
          "key_hash": "0x91cc77fe",
          "u64_hex": "0x0abc00001f40"
        }
      ],
      "encoding": "u64_port_claim"
    },
    "seq": 17,
    "epoch_ns": 1724370000000000000
  }
}
/// module/info/manifest.json ///
{
  "name": "Kubex Logz",
  "application": "logz",
  "version": "1.5.6",
  "private": false,
  "published": true,
  "aliases": [
    "logz"
  ],
  "repository": "https://github.com/kubex-ecosystem/logz",
  "homepage": "https://github.com/kubex-ecosystem/logz",
  "description": "Kubex Logz: A complete logging solution for your applications.",
  "main": "cmd/main.go",
  "go_version": "1.25.4",
  "bin": "logz",
  "author": "Rafael Mori <faelmori@gmail.com>",
  "organization": "kubex-ecosystem",
  "license": "MIT",
  "keywords": [
    "logz",
    "kubex",
    "control",
    "command-line",
    "tool",
    "management"
  ],
  "platforms": [
    "linux/amd64",
    "linux/arm64",
    "darwin/amd64",
    "darwin/arm64",
    "windows/amd64",
    "windows/386"
  ],
  "dependencies": [
    "tar",
    "gzip",
    "curl",
    "git",
    "zip",
    "unzip",
    "jq"
  ]
}
/// module/info/types.go ///
package info

type IPC struct {
	Type   string `json:"type"`
	Socket string `json:"socket"`
	Mode   string `json:"mode,omitempty"`
}

type Bitreg struct {
	BrfPath string `json:"brf_path"`
	NSBits  int    `json:"ns_bits"`
	Policy  string `json:"policy,omitempty"`

	// CapMask is a hexadecimal string representing the capability mask.
	CapMask string `json:"cap_mask,omitempty"`

	// StateHex is a hexadecimal string representing the state.
	StateHex string `json:"state_hex,omitempty"`
}

type KV struct {
	DeclareHashes []KeyHash `json:"declare_hashes,omitempty"`
	Values        []KVValue `json:"values,omitempty"`
	Encoding      string    `json:"encoding,omitempty"`
}

type KeyHash struct {
	KeyHash string `json:"key_hash"`
}

type KVValue struct {
	KeyHash string `json:"key_hash"`
	U64Hex  string `json:"u64_hex,omitempty"`
}
/// module/kbx/defaults.go ///
// Package kbx has default configuration values
package kbx

const (
	KeyringService        = "canalize"
	DefaultKubexConfigDir = "$HOME/.canalize"

	DefaultCanalizeBEKeyPath    = "$HOME/.canalize/gobe/gobe-key.pem"
	DefaultCanalizeBECertPath   = "$HOME/.canalize/gobe/gobe-cert.pem"
	DefaultCanalizeBECAPath     = "$HOME/.canalize/gobe/ca-cert.pem"
	DefaultCanalizeBEConfigPath = "$HOME/.canalize/gobe/config/config.json"

	DefaultConfigDir            = "$HOME/.canalize/logz/config"
	DefaultConfigFile           = "$HOME/.canalize/logz/config.json"
	DefaultCanalizeDSConfigPath = "$HOME/.canalize/logz/config/config.json"
)

const (
	DefaultVolumesDir     = "$HOME/.canalize/volumes"
	DefaultRedisVolume    = "$HOME/.canalize/volumes/redis"
	DefaultPostgresVolume = "$HOME/.canalize/volumes/postgresql"
	DefaultMongoDBVolume  = "$HOME/.canalize/volumes/mongodb"
	DefaultMongoVolume    = "$HOME/.canalize/volumes/mongo"
	DefaultRabbitMQVolume = "$HOME/.canalize/volumes/rabbitmq"
)

const (
	DefaultRateLimitLimit  = 100
	DefaultRateLimitBurst  = 100
	DefaultRequestWindow   = 1 * 60 * 1000 // 1 minute
	DefaultRateLimitJitter = 0.1
)

const (
	DefaultMaxRetries = 3
	DefaultRetryDelay = 1 * 1000 // 1 second
)

const (
	DefaultMaxIdleConns          = 100
	DefaultMaxIdleConnsPerHost   = 100
	DefaultIdleConnTimeout       = 90 * 1000 // 90 seconds
	DefaultTLSHandshakeTimeout   = 10 * 1000 // 10 seconds
	DefaultExpectContinueTimeout = 1 * 1000  // 1 second
	DefaultResponseHeaderTimeout = 5 * 1000  // 5 seconds
	DefaultTimeout               = 30 * 1000 // 30 seconds
	DefaultKeepAlive             = 30 * 1000 // 30 seconds
	DefaultMaxConnsPerHost       = 100
)

const (
	DefaultLLMProvider    = "gemini"
	DefaultLLMModel       = "gemini-2.0-flash"
	DefaultLLMMaxTokens   = 1024
	DefaultLLMTemperature = 0.3
)

const (
	DefaultApprovalRequireForResponses = false
	DefaultApprovalTimeoutMinutes      = 15
)

const (
	DefaultServerPort = "5000"
	DefaultServerHost = "0.0.0.0"
)

type ValidationError struct {
	Field   string
	Message string
}

func (v *ValidationError) Error() string {
	return v.Message
}
func (v *ValidationError) FieldError() map[string]string {
	return map[string]string{v.Field: v.Message}
}
func (v *ValidationError) FieldsError() map[string]string {
	return map[string]string{v.Field: v.Message}
}
func (v *ValidationError) ErrorOrNil() error {
	return v
}

var (
	ErrUsernameRequired = &ValidationError{Field: "username", Message: "Username is required"}
	ErrPasswordRequired = &ValidationError{Field: "password", Message: "Password is required"}
	ErrEmailRequired    = &ValidationError{Field: "email", Message: "Email is required"}
	ErrDBNotProvided    = &ValidationError{Field: "db", Message: "Database not provided"}
	ErrModelNotFound    = &ValidationError{Field: "model", Message: "Model not found"}
)
/// module/kbx/init_args.go ///
// Package kbx provides utilities for working with initialization arguments.
package kbx

type glgr interface {
	Log(level string, parts ...any)
}

var gl glgr

func SetLogger(logger glgr) {
	gl = logger
}

type DBType string

const (
	DBTypePostgres DBType = "postgres"
	DBTypeRabbitMQ DBType = "rabbitmq"
	DBTypeRedis    DBType = "redis"
	DBTypeMongoDB  DBType = "mongodb"
	DBTypeMySQL    DBType = "mysql"
	DBTypeMSSQL    DBType = "mssql"
	DBTypeSQLite   DBType = "sqlite"
	DBTypeOracle   DBType = "oracle"
)

type InitArgs struct {
	ConfigFile     string
	ConfigType     string
	EnvFile        string
	LogFile        string
	Name           string
	Image          string
	Debug          bool
	ReleaseMode    bool
	IsConfidential bool
	DryRun         bool
	Force          bool
	Reset          bool
	FailFast       bool
	BatchMode      bool
	NoColor        bool
	RootMode       bool
	Host           string
	Command        string
	Subcommand     string
	MaxProcs       int
	TimeoutMS      int
	EnvVars        map[string]string
	Ports          map[string]string
	Volumes        map[string]string
	Bind           string
	Address        string
	PubCertKeyPath string
	PubKeyPath     string
	Pwd            string

	Enabled  bool
	Port     string
	Hostname string
	Username string
	Password string
	Database string
	DSN      string
}

func Log(level string, payload ...any) {
	gl.Log(level, payload...)
}

type MigrationInfo struct {
	// MigrationPath é o caminho para os arquivos de migração.
	MigrationPath string `json:"migration_path,omitempty" yaml:"migration_path,omitempty" mapstructure:"migration_path,omitempty"`
	// Enabled indica se a migração está habilitada.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty" default:"false"`
	// Options são opções adicionais para a migração.
	Options map[string]any `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
	// Auto indica se a migração deve ser executada automaticamente.
	Auto *bool `json:"auto,omitempty" yaml:"auto,omitempty" mapstructure:"auto,omitempty" default:"false"`
	// Version indica a versão da migração.
	Version string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
	// Bootstrap indica se a migração deve ser inicializada.
	Bootstrap *bool `json:"bootstrap,omitempty" yaml:"bootstrap,omitempty" mapstructure:"bootstrap,omitempty" default:"false"`
	// DryRun indica se a migração deve ser executada em modo de simulação.
	DryRun *bool `json:"dry_run,omitempty" yaml:"dry_run,omitempty" mapstructure:"dry_run,omitempty" default:"false"`
	// Reset indica se a migração deve redefinir o banco de dados antes de aplicar as migrações.
	Reset *bool `json:"reset,omitempty" yaml:"reset,omitempty" mapstructure:"reset,omitempty" default:"false"`
	// Force indica se a migração deve forçar a aplicação de todas as migrações.
	Force *bool `json:"force,omitempty" yaml:"force,omitempty" mapstructure:"force,omitempty" default:"false"`
}

// DBConfig is the pure, serializable configuration for a single database.
type DBConfig struct {
	ID         string         `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`
	Name       string         `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
	IsDefault  bool           `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`
	Enabled    *bool          `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty" default:"true"`
	Debug      bool           `json:"debug,omitempty" yaml:"debug,omitempty" mapstructure:"debug,omitempty"`
	Type       DBType         `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"Type,omitempty" validate:"required,oneof=postgres rabbitmq redis mongodb mysql mssql sqlite oracle"`
	Host       string         `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`
	Port       string         `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
	User       string         `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
	Pass       string         `json:"pass,omitempty" yaml:"pass,omitempty" mapstructure:"pass,omitempty"`
	TLSEnabled bool           `json:"tls_enabled,omitempty" yaml:"tls_enabled,omitempty" mapstructure:"tls_enabled,omitempty"`
	DBName     string         `json:"db_name,omitempty" yaml:"db_name,omitempty" mapstructure:"db_name,omitempty"`
	Schema     string         `json:"schema,omitempty" yaml:"schema,omitempty" mapstructure:"schema,omitempty"`
	DSN        string         `json:"dsn,omitempty" yaml:"dsn,omitempty" mapstructure:"dsn,omitempty"`
	Options    map[string]any `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
	Backend    string         `json:"backend,omitempty" yaml:"backend,omitempty" mapstructure:"backend,omitempty"`
	Migration  *MigrationInfo `json:"migration,omitempty" yaml:"migration,omitempty" mapstructure:"migration,omitempty" validate:"omitempty,object"`
}

// RootConfig representa o arquivo de configuração do DS.
type RootConfig struct {
	Name      string      `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
	FilePath  string      `json:"file_path,omitempty" yaml:"file_path,omitempty" mapstructure:"file_path,omitempty"`
	Enabled   *bool       `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty" default:"true"`
	Databases []*DBConfig `json:"databases,omitempty" yaml:"databases,omitempty" mapstructure:"databases,omitempty"`
}
/// module/kbx/utils.go ///
package kbx

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
)

var (
	validKindMap = map[string]reflect.Kind{
		reflect.Struct.String():    reflect.Struct,
		reflect.Map.String():       reflect.Map,
		reflect.Slice.String():     reflect.Slice,
		reflect.Array.String():     reflect.Array,
		reflect.Chan.String():      reflect.Chan,
		reflect.Interface.String(): reflect.Interface,
		reflect.Ptr.String():       reflect.Ptr,
		reflect.String.String():    reflect.String,
		reflect.Int.String():       reflect.Int,
		reflect.Float32.String():   reflect.Float32,
		reflect.Float64.String():   reflect.Float64,
		reflect.Bool.String():      reflect.Bool,
		reflect.Uint.String():      reflect.Uint,
		reflect.Uint8.String():     reflect.Uint8,
		reflect.Uint16.String():    reflect.Uint16,
		reflect.Uint32.String():    reflect.Uint32,
		reflect.Uint64.String():    reflect.Uint64,
	}
)

func GetEnvOrDefault(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}

func GetValueOrDefault[T any](value T, defaultValue T) (T, reflect.Type) {
	if !IsObjValid(value) {
		return defaultValue, reflect.TypeFor[T]()
	}
	return value, reflect.TypeFor[T]()
}

func GetValueOrDefaultSimple[T any](value T, defaultValue T) T {
	if !IsObjValid(value) {
		return defaultValue
	}
	return value
}

func IsObjValid(obj any) bool {
	v := reflect.ValueOf(obj)
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		if v.IsNil() {
			return false
		}
		if v.Kind() == reflect.Ptr {
			if v.Elem().Kind() == reflect.Ptr && v.Elem().IsNil() {
				return false
			}
			v = v.Elem()
		}
	}
	if _, ok := validKindMap[v.Kind().String()]; !ok {
		return false
	}
	if !v.IsValid() {
		return false
	}
	if v.IsZero() {
		return false
	}
	if v.Kind() == reflect.String && v.Len() == 0 {
		return false
	}
	if (v.Kind() == reflect.Slice || v.Kind() == reflect.Map || v.Kind() == reflect.Array) && v.Len() == 0 {
		return false
	}
	if v.Kind() == reflect.Bool {
		return true
	}
	return true
}

func IsObjSafe(obj any, strict bool) bool {
	v := reflect.ValueOf(obj)

	// nil pointers or invalid values
	if !v.IsValid() {
		return false
	}
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		if v.IsNil() {
			return false
		}
		v = v.Elem()
	}

	// zero value check (different meaning in strict vs resilient mode)
	if v.IsZero() {
		if strict {

			switch v.Kind() {
			case reflect.Bool, reflect.Int, reflect.Int64, reflect.Float64, reflect.String:
				// 0, false, "" são válidos em modo estrito
				return true
			}
		}
		return false
	}

	// empty collections → false no resilient mode
	switch v.Kind() {
	case reflect.Slice, reflect.Array, reflect.Map:
		if v.Len() == 0 {
			return !strict
		}
	}

	return true
}

func GetEnvOrDefaultWithType[T any](key string, defaultValue T) T {
	value := os.Getenv(key)
	// Sempre vem texto da env
	if len(value) == 0 {
		return defaultValue
	}
	if reflect.ValueOf(value).CanConvert(reflect.TypeFor[T]()) {
		return reflect.ValueOf(value).Convert(reflect.TypeFor[T]()).Interface().(T)
	}
	var result T
	if err := json.Unmarshal([]byte(value), &result); err != nil {
		return defaultValue
	}
	if IsObjValid(result) {
		return result
	}
	return result
}

func GetValueOrDefaultAny[T any](value T, defaultValue T) T {
	if !IsObjValid(value) {
		return defaultValue
	}
	return value
}

func HydrateMapFromEnvOrDefaults[T any](dbType string, target map[string]T, defaults map[string]T, hydrationCtl chan any) map[string]T {
	defer func(hCtl chan any) {
		if r := recover(); r != nil {
			// Handle the panic (e.g., log the error)
			gl.Log("error", fmt.Sprintf("Panic at the Hydration: %v", r))
			if hydrationCtl != nil {
				gl.Log("info", "HydrationCtl", "Async hydration due to panic recovery")
				for key, defaultValue := range defaults {
					target[key] = GetValueOrDefaultAny(target[key], defaultValue)
				}
				hydrationCtl <- r
				return
			}
		}
	}(hydrationCtl)

	for key, defaultValue := range defaults {
		target[key] = GetEnvOrDefaultWithType(dbType+"_"+key,
			GetValueOrDefaultAny(target[key], defaultValue),
		)
	}

	gl.Log("debug", fmt.Sprintf("Hydrated Map for DBType %s: %+v", dbType, target))

	return target
}

func BoolPtr(b bool) *bool {
	return &b
}

func DefaultTrue(b *bool) bool {
	if b == nil {
		return true
	}
	return *b
}

func DefaultFalse(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}
/// module/module.go ///
// Package module provides internal types and functions for the GoBE application.
package module

import (
	"github.com/kubex-ecosystem/logz/cmd/cli"
	"github.com/kubex-ecosystem/logz/internal/module/info"
	"github.com/kubex-ecosystem/logz/internal/module/version"
	"github.com/spf13/cobra"

	"os"
	"strings"
)

type glgr interface {
	Log(level string, parts ...any)
}

var gl glgr

func SetLogger(logger glgr) {
	gl = logger
}

type LogZ struct {
	parentCmdName string
	hideBanner    bool
	certPath      string
	keyPath       string
	configPath    string
}

func (m *LogZ) Alias() string {
	return ""
}
func (m *LogZ) ShortDescription() string {
	return "LogZ: A Kubex Ecosystem Logging Tool"
}
func (m *LogZ) LongDescription() string {
	return `LogZ: A Kubex Ecosystem Logging Tool for managing logs and events, providing insights into system performance and security.`
}
func (m *LogZ) Usage() string {
	return "logz [command] [args]"
}
func (m *LogZ) Examples() []string {
	return []string{"logz -l info -m file -o /path/to/logfile.log",
		"logz -l debug -m json -o /path/to/logfile.json",
		"logz -l warn -m stdout",
		"logz -l error -m stderr",
		"logz -l fatal -m file -o /path/to/logfile.log",
	}
}
func (m *LogZ) Active() bool {
	return true
}
func (m *LogZ) Module() string {
	return "logz"
}
func (m *LogZ) Execute() error {
	dbChanData := make(chan interface{})
	defer close(dbChanData)

	if spyderErr := m.Command().Execute(); spyderErr != nil {
		gl.Log("error", spyderErr.Error())
		return spyderErr
	} else {
		return nil
	}
}
func (m *LogZ) Command() *cobra.Command {
	cmd := &cobra.Command{
		Use: m.Module(),
		//Aliases:     []string{m.Alias(), "w", "wb", "webServer", "http"},
		Example: m.concatenateExamples(),
		Annotations: m.GetDescriptions(
			[]string{
				m.LongDescription(),
				m.ShortDescription(),
			}, m.hideBanner,
		),
		Version: version.GetVersion(),
		Run: func(cmd *cobra.Command, args []string) {
			_ = cmd.Help()
		},
	}

	cmd.AddCommand(version.CliCommand())
	cmd.AddCommand(cli.MetricsCmd())

	setUsageDefinition(cmd)
	for _, c := range cmd.Commands() {
		setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return cmd
}

func (m *LogZ) GetDescriptions(descriptionArg []string, hideBanner bool) map[string]string {
	return info.GetDescriptions(descriptionArg, (m.hideBanner || hideBanner))
}
func (m *LogZ) SetParentCmdName(rtCmd string) {
	m.parentCmdName = rtCmd
}
func (m *LogZ) concatenateExamples() string {
	examples := ""
	rtCmd := m.parentCmdName
	if rtCmd != "" {
		rtCmd = rtCmd + " "
	}
	for _, example := range m.Examples() {
		examples += rtCmd + example + "\n  "
	}
	return examples
}
/// module/usage.go ///
package module

import (
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

// colorYellow, colorGreen, colorBlue, colorRed, and colorHelp are utility functions
// that return a string formatted with the specified color using the fatih/color package.
// These functions are used to colorize output in the CLI usage template.
// They are registered as template functions in the CLI usage template to allow
// coloring specific parts of the command usage output.
func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}

func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}

func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}

func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}

func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}

func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}

func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}

func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`
/// module/version/semantic.go ///
// Package version provides functionality to manage and check the version of the Kubex Horizon CLI tool.
// It includes methods to retrieve the current version, check for the latest version,
package version

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	manifest "github.com/kubex-ecosystem/logz/internal/module/info"
	"github.com/spf13/cobra"
)

type glgr interface {
	Log(level string, parts ...any)
}

var gl glgr

func SetLogger(logger glgr) {
	gl = logger
}

var (
	info, err = manifest.GetManifest()
	vrs       Service
)

func init() {
	if info == nil {
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
}

type Service interface {
	// GetLatestVersion retrieves the latest version from the Git repository.
	GetLatestVersion() (string, error)
	// GetCurrentVersion returns the current version of the service.
	GetCurrentVersion() string
	// IsLatestVersion checks if the current version is the latest version.
	IsLatestVersion() (bool, error)
	// GetName returns the name of the service.
	GetName() string
	// GetVersion returns the current version of the service.
	GetVersion() string
	// GetRepository returns the Git repository URL of the service.
	GetRepository() string
	// setLastCheckedAt sets the last checked time for the version.
	setLastCheckedAt(time.Time)
	// updateLatestVersion updates the latest version from the Git repository.
	updateLatestVersion() error
}
type ServiceImpl struct {
	manifest.Manifest
	gitModelURL    string
	latestVersion  string
	lastCheckedAt  time.Time
	currentVersion string
}

func init() {
	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
	if vrs == nil {
		vrs = NewVersionService()
	}
}

func getLatestTag(repoURL string) (string, error) {
	defer func() {
		if rec := recover(); rec != nil {
			gl.Log("error", "Recovered from panic in getLatestTag: %v", rec)
			err = fmt.Errorf("panic occurred while fetching latest tag: %v", rec)
		}
	}()

	defer func() {
		if vrs == nil {
			vrs = NewVersionService()
		}
		vrs.setLastCheckedAt(time.Now())
	}()

	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			return "", fmt.Errorf("failed to get manifest: %w", err)
		}
	}
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest tag for private repositories")
	}

	if repoURL == "" {
		repoURL = info.GetRepository()
		if repoURL == "" {
			return "", fmt.Errorf("repository URL is not set")
		}
	}

	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}
	type Tag struct {
		Name string `json:"name"`
	}

	// Decode the JSON response into a slice of Tag structs
	// This assumes the API returns a JSON array of tags.
	// Adjust the decoding logic based on the actual API response structure.
	if resp.Header.Get("Content-Type") != "application/json" {
		return "", fmt.Errorf("expected application/json, got %s", resp.Header.Get("Content-Type"))
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}
	return tags[0].Name, nil
}
func (v *ServiceImpl) updateLatestVersion() error {
	if info.IsPrivate() {
		return fmt.Errorf("cannot fetch latest version for private repositories")
	}
	repoURL := strings.TrimSuffix(v.gitModelURL, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	compare := 0
	for i := 0; i < len(v1) && i < len(v2); i++ {
		if v1[i] < v2[i] {
			compare = -1
			break
		}
		if v1[i] > v2[i] {
			compare = 1
			break
		}
	}
	return compare, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	if versionToParse == "" {
		return nil
	}
	if strings.Contains(versionToParse, "-") {
		versionToParse = strings.Split(versionToParse, "-")[0]
	}
	if strings.Contains(versionToParse, "v") {
		versionToParse = strings.TrimPrefix(versionToParse, "v")
	}
	parts := strings.Split(versionToParse, ".")
	parsedVersion := make([]int, len(parts))
	for i, part := range parts {
		if num, err := strconv.Atoi(part); err != nil {
			return nil
		} else {
			parsedVersion[i] = num
		}
	}
	return parsedVersion
}
func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if info.IsPrivate() {
		return false, fmt.Errorf("cannot check version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	currentVersionParts := v.parseVersion(v.currentVersion)
	latestVersionParts := v.parseVersion(v.latestVersion)

	if len(currentVersionParts) == 0 || len(latestVersionParts) == 0 {
		return false, fmt.Errorf("invalid version format")
	}

	if len(currentVersionParts) != len(latestVersionParts) {
		return false, fmt.Errorf("version parts length mismatch")
	}

	return v.versionAtMost(currentVersionParts, latestVersionParts)
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}
	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string {
	if v.currentVersion == "" {
		v.currentVersion = info.GetVersion()
	}
	return v.currentVersion
}
func (v *ServiceImpl) GetName() string {
	if info == nil {
		return "Unknown Service"
	}
	return info.GetName()
}
func (v *ServiceImpl) GetVersion() string {
	if info == nil {
		return "Unknown version"
	}
	return info.GetVersion()
}
func (v *ServiceImpl) GetRepository() string {
	if info == nil {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func (v *ServiceImpl) setLastCheckedAt(t time.Time) {
	v.lastCheckedAt = t
	gl.Log("debug", "Last checked at: "+t.Format(time.RFC3339))
}

func NewVersionService() Service {
	return &ServiceImpl{
		Manifest:       info,
		gitModelURL:    info.GetRepository(),
		currentVersion: info.GetVersion(),
		latestVersion:  "",
	}
}

var (
	versionCmd   *cobra.Command
	subLatestCmd *cobra.Command
	subCmdCheck  *cobra.Command
	updCmd       *cobra.Command
	getCmd       *cobra.Command
	restartCmd   *cobra.Command
)

func init() {
	if versionCmd == nil {
		versionCmd = &cobra.Command{
			Use:   "version",
			Short: "Print the version number of " + info.GetName(),
			Long:  "Print the version number of " + info.GetName() + " and other related information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("warn", "The information shown may not be accurate for private repositories.")
					gl.Log("info", "Current version: "+GetVersion())
					gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
					return
				}
				GetVersionInfo()
			},
		}
	}
	if subLatestCmd == nil {
		subLatestCmd = &cobra.Command{
			Use:   "latest",
			Short: "Print the latest version number of " + info.GetName(),
			Long:  "Print the latest version number of " + info.GetName() + " from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot fetch latest version for private repositories.")
					return
				}
				GetLatestVersionInfo()
			},
		}
	}
	if subCmdCheck == nil {
		subCmdCheck = &cobra.Command{
			Use:   "check",
			Short: "Check if the current version is the latest version of " + info.GetName(),
			Long:  "Check if the current version is the latest version of " + info.GetName() + " and print the version information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot check version for private repositories.")
					return
				}
				GetVersionInfoWithLatestAndCheck()
			},
		}
	}
	if updCmd == nil {
		updCmd = &cobra.Command{
			Use:   "update",
			Short: "Update the version information of " + info.GetName(),
			Long:  "Update the version information of " + info.GetName() + " by fetching the latest version from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot update version for private repositories.")
					return
				}
				if err := vrs.updateLatestVersion(); err != nil {
					gl.Log("error", "Failed to update version: "+err.Error())
				} else {
					latestVersion, err := vrs.GetLatestVersion()
					if err != nil {
						gl.Log("error", "Failed to get latest version: "+err.Error())
					} else {
						gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
						gl.Log("info", "Latest version: "+latestVersion)
					}
					vrs.setLastCheckedAt(time.Now())
				}
			},
		}
	}
	if getCmd == nil {
		getCmd = &cobra.Command{
			Use:   "get",
			Short: "Get the current version of " + info.GetName(),
			Long:  "Get the current version of " + info.GetName() + " from the manifest.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
			},
		}
	}
	if restartCmd == nil {
		restartCmd = &cobra.Command{
			Use:   "restart",
			Short: "Restart the " + info.GetName() + " service",
			Long:  "Restart the " + info.GetName() + " service to apply any changes made.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Restarting the service...")
				// Logic to restart the service can be added here
				gl.Log("success", "Service restarted successfully")
			},
		}
	}

}
func GetVersion() string {
	if info == nil {
		_, err := manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
			return "Unknown version"
		}
	}
	return info.GetVersion()
}
func GetGitRepositoryModelURL() string {
	if info.GetRepository() == "" {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitRepositoryModelURL())
}
func GetLatestVersionFromGit() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}

	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitURLWithoutGit := strings.TrimSuffix(GetGitRepositoryModelURL(), ".git")
	if gitURLWithoutGit == "" {
		gl.Log("error", "No repository URL set in the manifest.")
		return "No repository URL set in the manifest."
	}

	response, err := netClient.Get(gitURLWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "Error fetching latest version: "+err.Error())
		gl.Log("error", gitURLWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "Error fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitURLWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("Error: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}
func GetLatestVersionInfo() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}
func GetVersionInfoWithLatestAndCheck() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot check version for private repositories.")
		return "Cannot check version for private repositories."
	}
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}
func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	versionCmd.AddCommand(updCmd)
	versionCmd.AddCommand(getCmd)
	versionCmd.AddCommand(restartCmd)
	return versionCmd
}
/// module/wrpr.go ///
package module

import (
	"os"
	"strings"
)

func RegX() *LogZ {
	var configPath = os.Getenv("CANALIZEDS_CONFIGFILE")
	var keyPath = os.Getenv("CANALIZEDS_KEYFILE")
	var certPath = os.Getenv("CANALIZEDS_CERTFILE")
	var hideBannerV = os.Getenv("CANALIZEDS_HIDEBANNER")

	return &LogZ{
		configPath: configPath,
		keyPath:    keyPath,
		certPath:   certPath,
		hideBanner: (strings.ToLower(hideBannerV) == "true" ||
			strings.ToLower(hideBannerV) == "1" ||
			strings.ToLower(hideBannerV) == "yes" ||
			strings.ToLower(hideBannerV) == "y"),
	}
}
/// services/prometheus.go ///
// Package services provides various services for the application.
package services

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

// Regular expression to validate metric names
var metricNameRegex = regexp.MustCompile(`^[a-zA-Z_:][a-zA-Z0-9_:]*$`)

// validateMetricName checks if the given metric name is valid according to the Prometheus naming conventions.
func validateMetricName(name string) error {
	if !metricNameRegex.MatchString(name) {
		return fmt.Errorf("invalid metric name '%s': must match [a-zA-Z_:][a-zA-Z0-9_:]*", name)
	}
	return nil
}

// Metric represents a single Prometheus metric with a value and optional VMetadata.
type Metric struct {
	Value    float64           `json:"value"`
	Metadata map[string]string `json:"VMetadata,omitempty"`
}

// PrometheusManager manages Prometheus metrics, including enabling/disabling the HTTP server,
// loading/saving metrics, and handling metric operations.
type PrometheusManager struct {
	enabled         bool
	Metrics         map[string]Metric
	mutex           sync.RWMutex
	MetricsFile     string          // path to the persistence file
	exportWhitelist map[string]bool // If not empty, only these metrics will be exported to Prometheus
	httpServer      *http.Server    // HTTP server to expose metrics
}

// Singleton instance of PrometheusManager
var prometheusManagerInstance *PrometheusManager

// getMetricsFilePath returns the path to the metrics persistence file, using an environment variable if set,
// or a default location in the user's cache directory.
func getMetricsFilePath() string {
	if envPath := os.Getenv("LOGZ_METRICS_FILE"); envPath != "" {
		return envPath
	}
	cacheDir, err := os.UserCacheDir()
	if err != nil {
		cacheDir = "/tmp"
	}
	dir := filepath.Join(cacheDir, "kubex", "logz")
	_ = os.MkdirAll(dir, 0755)
	return filepath.Join(dir, "metrics.json")
}

// GetPrometheusManager returns the singleton instance of PrometheusManager, initializing it if necessary.
func GetPrometheusManager() *PrometheusManager {
	if prometheusManagerInstance == nil {
		prometheusManagerInstance = &PrometheusManager{
			enabled:         false,
			Metrics:         make(map[string]Metric),
			MetricsFile:     getMetricsFilePath(),
			exportWhitelist: make(map[string]bool),
		}
		if err := prometheusManagerInstance.LoadMetrics(); err != nil {
			fmt.Printf("Warning: could not load metrics: %v\n", err)
		}
	}
	return prometheusManagerInstance
}

// LoadMetrics loads metrics from the persistence file into the PrometheusManager instance.
func (pm *PrometheusManager) LoadMetrics() error {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	data, err := os.ReadFile(pm.MetricsFile)
	if err != nil {
		if os.IsNotExist(err) {
			pm.Metrics = make(map[string]Metric)
			return nil
		}
		return err
	}
	var loaded map[string]Metric
	if err := json.Unmarshal(data, &loaded); err != nil {
		return err
	}
	pm.Metrics = loaded
	return nil
}

// SaveMetrics saves the current metrics to the persistence file.
func (pm *PrometheusManager) SaveMetrics() error {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	data, err := json.MarshalIndent(pm.Metrics, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(pm.MetricsFile, data, 0644)
}

// Enable starts the Prometheus HTTP server on the specified port to expose metrics.
func (pm *PrometheusManager) Enable(port string) {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	if pm.enabled {
		fmt.Println("Prometheus metrics are already enabled.")
		return
	}
	pm.enabled = true

	// Start the HTTP server to expose metrics
	mux := http.NewServeMux()
	mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
		metrics := pm.GetMetrics()
		w.Header().Set("Content-Type", "text/plain; version=0.0.4")
		for name, value := range metrics {
			_, fPrintFErr := fmt.Fprintf(w, "# TYPE %s gauge\n%s %f\n", name, name, value)
			if fPrintFErr != nil {
				return
			}
		}
	})
	pm.httpServer = &http.Server{
		Addr:    fmt.Sprintf(":%s", port),
		Handler: mux,
	}
	go func() {
		if err := pm.httpServer.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			fmt.Printf("ErrorCtx starting Prometheus metrics server: %v\n", err)
		}
	}()
	fmt.Println("Prometheus metrics enabled.")
}

// Disable stops the Prometheus HTTP server and disables metric exposure.
func (pm *PrometheusManager) Disable() {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	if !pm.enabled {
		fmt.Println("Prometheus metrics are already disabled.")
		return
	}
	pm.enabled = false
	if pm.httpServer != nil {
		_ = pm.httpServer.Close()
	}
	fmt.Println("Prometheus metrics disabled.")
}

// GetMetrics returns the current metrics, filtered by the export whitelist if defined.
func (pm *PrometheusManager) GetMetrics() map[string]float64 {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	filteredMetrics := make(map[string]float64)
	for name, metric := range pm.Metrics {
		// Respect the exportWhitelist, if defined
		if len(pm.exportWhitelist) > 0 && !pm.exportWhitelist[name] {
			continue
		}
		filteredMetrics[name] = metric.Value
	}
	return filteredMetrics
}

// SetExportWhitelist sets the list of metrics that are allowed to be exported to Prometheus.
func (pm *PrometheusManager) SetExportWhitelist(metrics []string) {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	pm.exportWhitelist = make(map[string]bool)
	for _, m := range metrics {
		pm.exportWhitelist[m] = true
	}
	fmt.Println("Export whitelist updated for Prometheus metrics.")
}

// IsEnabled returns whether the Prometheus metrics exposure is enabled.
func (pm *PrometheusManager) IsEnabled() bool {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	return pm.enabled
}

// AddMetric adds or updates a metric with the given name, value, and VMetadata.
func (pm *PrometheusManager) AddMetric(name string, value float64, metadata map[string]string) {
	if err := validateMetricName(name); err != nil {
		fmt.Printf("ErrorCtx adding metric: %v\n", err)
		return
	}
	pm.mutex.Lock()
	pm.Metrics[name] = Metric{
		Value:    value,
		Metadata: metadata,
	}
	pm.mutex.Unlock()

	fmt.Printf("Metric '%s' added/updated with value: %f\n", name, value)
	if err := pm.SaveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// RemoveMetric removes a metric with the given name.
func (pm *PrometheusManager) RemoveMetric(name string) {
	pm.mutex.Lock()
	delete(pm.Metrics, name)
	pm.mutex.Unlock()

	fmt.Printf("Metric '%s' removed.\n", name)
	if err := pm.SaveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// IncrementMetric increments the value of a metric by the given delta.
func (pm *PrometheusManager) IncrementMetric(name string, delta float64) {
	if err := validateMetricName(name); err != nil {
		fmt.Printf("ErrorCtx incrementing metric: %v\n", err)
		return
	}
	pm.mutex.Lock()
	metric, exists := pm.Metrics[name]
	if !exists {
		metric = Metric{Value: 0, Metadata: nil}
	}
	metric.Value += delta
	pm.Metrics[name] = metric
	pm.mutex.Unlock()

	fmt.Printf("Metric '%s' incremented by %f, new value: %f\n", name, delta, metric.Value)
	if err := pm.SaveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// ListMetrics prints all registered metrics to the console.
func (pm *PrometheusManager) ListMetrics() {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	if len(pm.Metrics) == 0 {
		fmt.Println("No metrics registered.")
		return
	}
	fmt.Println("Registered metrics:")
	for name, metric := range pm.Metrics {
		fmt.Printf("- %s: %f", name, metric.Value)
		if len(metric.Metadata) > 0 {
			metadataJSON, _ := json.Marshal(metric.Metadata)
			fmt.Printf(" (VMetadata: %s)", string(metadataJSON))
		}
		fmt.Println()
	}
}

// setPrometheusSysConfig configures the Prometheus system to scrape metrics from this application.
func (pm *PrometheusManager) setPrometheusSysConfig() error {
	// Logz specific configuration for Prometheus
	prometheusConfig := `
scrape_configs:
  - job_name: 'logz'
    static_configs:
      - targets: ['localhost:2112']
`

	configFilePath := "/etc/prometheus/prometheus.yml"

	// Check if the configuration file exists
	_, err := os.Stat(configFilePath)
	if os.IsNotExist(err) {
		// Create the configuration file if it does not exist
		if err := os.WriteFile(configFilePath, []byte(prometheusConfig), 0644); err != nil {
			return fmt.Errorf("failed to create Prometheus configuration file: %w", err)
		}
		fmt.Println("Prometheus configuration file created successfully.")
	} else if err == nil {
		// Check if there is already a configuration for 'logz'
		configContent, readErr := os.ReadFile(configFilePath)
		if readErr != nil {
			return fmt.Errorf("failed to read Prometheus configuration file: %w", readErr)
		}

		if strings.Contains(string(configContent), "job_name: 'logz'") {
			fmt.Println("Prometheus configuration for 'logz' already exists.")
		} else {
			// Add the configuration to the existing file
			f, openErr := os.OpenFile(configFilePath, os.O_APPEND|os.O_WRONLY, 0644)
			if openErr != nil {
				return fmt.Errorf("failed to open Prometheus configuration file: %w", openErr)
			}
			defer func(f *os.File) {
				_ = f.Close()
			}(f)

			if _, writeErr := f.WriteString(prometheusConfig); writeErr != nil {
				return fmt.Errorf("failed to append to Prometheus configuration file: %w", writeErr)
			}
			fmt.Println("Prometheus configuration for 'logz' added successfully.")
		}
	} else {
		return fmt.Errorf("failed to check Prometheus configuration file: %w", err)
	}

	return nil
}

// initPrometheus initializes the Prometheus metrics and system configuration.
func (pm *PrometheusManager) initPrometheus() error {
	if !pm.IsEnabled() {
		return fmt.Errorf("prometheus is not enabled")
	}

	defaultMetrics := []string{"infoCount", "warnCount", "errorCount", "debugCount", "successCount"}
	for _, metric := range defaultMetrics {
		if err := validateMetricName(metric); err != nil {
			fmt.Printf("ErrorCtx initializing metric '%s': %v\n", metric, err)
			continue
		}
		pm.AddMetric(metric, 0, nil) // Initialize with value 0 and no VMetadata
	}

	if err := pm.setPrometheusSysConfig(); err != nil {
		return fmt.Errorf("failed to configure Prometheus system: %w", err)
	}

	fmt.Println("Prometheus initialized successfully with default metrics.")
	return nil
}
/// writer/dynamic_writer.go ///
package logz

import "sync"

// DynamicWriter permite trocar o destino em runtime.
type DynamicWriter struct {
	mu     sync.RWMutex
	target Writer
}

func NewDynamicWriter(initial Writer) *DynamicWriter {
	return &DynamicWriter{target: initial}
}

func (d *DynamicWriter) Set(w Writer) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.target = w
}

func (d *DynamicWriter) Write(b []byte) error {
	d.mu.RLock()
	t := d.target
	d.mu.RUnlock()
	if t == nil {
		return nil
	}
	return t.Write(b)
}

func (d *DynamicWriter) Close() error {
	d.mu.RLock()
	t := d.target
	d.mu.RUnlock()
	if t == nil {
		return nil
	}
	return t.Close()
}
/// writer/io_writer.go ///
package logz

import (
	"io"
	"sync"
)

type IOWriter struct {
	w  io.Writer
	mu sync.Mutex
}

func NewIOWriter(w io.Writer) *IOWriter {
	return &IOWriter{w: w}
}

func (w *IOWriter) Write(b []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()
	_, err := w.w.Write(b)
	return err
}

func (w *IOWriter) Close() error {
	if c, ok := w.w.(io.Closer); ok {
		return c.Close()
	}
	return nil
}
/// writer/multi_writer.go ///
package logz

type MultiWriter struct {
	writers []Writer
}

func NewMultiWriter(writers ...Writer) *MultiWriter {
	return &MultiWriter{writers: writers}
}

func (m *MultiWriter) Write(b []byte) error {
	var lastErr error
	for _, w := range m.writers {
		if err := w.Write(b); err != nil {
			lastErr = err
		}
	}
	return lastErr
}

func (m *MultiWriter) Close() error {
	var lastErr error
	for _, w := range m.writers {
		if err := w.Close(); err != nil {
			lastErr = err
		}
	}
	return lastErr
}
/// writer/writer.go ///
package logz

// Writer recebe bytes já formatados e empurra pra algum destino.
// NÃO sabe nada sobre Entry.
type Writer interface {
	Write([]byte) error
	Close() error
}
